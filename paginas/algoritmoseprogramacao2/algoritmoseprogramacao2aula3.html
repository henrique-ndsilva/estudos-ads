---
---

{% include head-aula.html page-title="Aula 3 - AeP2" %}

{% include heading-aula.html heading="Manipulação de Arquivos em C#" %}

<p>Até agora, todos os dados que nossos programas utilizaram (como a posição das bombas no Campo Minado) eram perdidos
    quando o programa fechava. Para resolver isso, precisamos de um método de <strong>persistência de dados</strong>, ou
    seja, uma forma de salvar informações para que possam ser recuperadas depois. A maneira mais direta de fazer isso é
    através da manipulação de arquivos de texto. Neste capítulo, aprenderemos a ler e escrever em arquivos para salvar o
    layout do nosso jogo e o placar de vitórias e derrotas.</p>

<h2>1. O Básico sobre Arquivos e Caminhos</h2>

<p>Quando um programa precisa ler ou escrever em um arquivo, ele estabelece um "fluxo" de comunicação. Para evitar que
    outro programa (ou até o próprio usuário) modifique o arquivo ao mesmo tempo e cause erros, o arquivo fica "travado"
    durante o uso. Por isso, o procedimento padrão é sempre:</p>
<ol>
    <li><strong>Abrir</strong> o fluxo para o arquivo.</li>
    <li><strong>Realizar</strong> as operações de leitura ou escrita.</li>
    <li><strong>Fechar</strong> o fluxo para liberar o arquivo.</li>
</ol>

<h3>1.1 Localização do Arquivo e Caminhos</h3>
<p>Para que nosso programa encontre o arquivo, precisamos dizer a ele onde procurar. Existem duas formas de fazer isso:
    usando um caminho <strong>absoluto</strong> ou <strong>relativo</strong>.</p>
<p>Primeiro, crie um arquivo chamado <code>campo.txt</code> e salve-o na pasta principal do seu projeto (no mesmo local
    do arquivo <code>.sln</code>), como mostra a figura:</p>
<img src="../../imagens/algoritmoseprogramacao2/aula3/figura1.png"
    alt="Localização do arquivo campo.txt na pasta do projeto">
<br>

<h4>Caminho Absoluto</h4>
<p>É o endereço completo do arquivo, começando da raiz do seu HD (como <code>C:\</code>). É específico para cada
    computador. Ao usar em uma string em C#, precisamos duplicar as barras invertidas (<code>\\</code>) para que a
    linguagem não as confunda com caracteres de comando.</p>
<pre class="code">
// Exemplo de caminho absoluto em uma string C#
string caminho_absoluto = "C:\\Users\\Rafael\\source\\repos\\Capitulo3\\campo.txt";</pre>

<h4>Caminho Relativo</h4>
<p>É o endereço do arquivo tomando como ponto de partida o local onde o programa está sendo <strong>executado</strong>.
    No caso de um projeto C# no Visual Studio, o executável fica numa pasta como <code>bin\Debug\netcoreappX.X</code>.
    Para chegar ao nosso arquivo na raiz do projeto, precisamos "subir" alguns níveis de pasta. Usamos <code>..</code>
    para subir um nível.</p>
<img src="../../imagens/algoritmoseprogramacao2/aula3/figura2.png" alt="Localização da pasta de execução do projeto">
<br>
<pre class="code">
// Exemplo de caminho relativo para subir 4 níveis e encontrar o arquivo
string caminho_relativo = "..\\..\\..\\..\\campo.txt";</pre>

<hr>

<h2>2. Leitura de Dados de um Arquivo</h2>

<p>Vamos alterar nosso Campo Minado para que ele carregue o mapa e o placar do arquivo <code>campo.txt</code>. O arquivo
    precisa ter um formato específico para que o programa consiga entendê-lo: 10 linhas para o campo (com números
    separados por vírgula), uma linha em branco, uma linha para vitórias e uma para derrotas.</p>
<img src="../../imagens/algoritmoseprogramacao2/aula3/figura3.png" alt="Estrutura do arquivo de texto a ser lido">
<br>

<h3>Código para Leitura e Explicação</h3>
<p>O código a seguir abre o arquivo, lê os dados e monta o tabuleiro do jogo.</p>
<pre class="code">
int[,] campo = new int[10, 10];
int[,] jogo = new int[10, 10];
int qtdLinhas = campo.GetLength(0);
int qtdColunas = campo.GetLength(1);
bool problemaArquivo = false;
string caminho_relativo = "..\\..\\..\\..\\campo.txt";

try
{
    // 1. Cria um leitor de fluxo para o arquivo especificado
    StreamReader sr = new StreamReader(caminho_relativo);
    
    string linha_arq = sr.ReadLine(); // 2. Lê a primeira linha do arquivo
    int linha_mtz = 0;

    // 3. Continua lendo linha por linha, até o fim do arquivo ou até ler as 10 linhas do campo
    while (linha_arq != null && linha_mtz < 10)
    {
        int coluna_mtz = 0;
        // 4. Separa a string da linha pela vírgula (ex: "0,0,1,0...") em várias strings menores ("0", "0", "1", "0"...)
        foreach (var numero in linha_arq.Split(','))
        {
            int num;
            // 5. Tenta converter a string para um número inteiro de forma segura
            if (int.TryParse(numero, out num))
            {
                campo[linha_mtz, coluna_mtz] = num; // Armazena na matriz do campo
                jogo[linha_mtz, coluna_mtz] = -1;  // Inicia a matriz do jogador
                coluna_mtz++;
            }
        }
        linha_arq = sr.ReadLine(); // Lê a próxima linha
        linha_mtz++;
    }

    // 6. Fecha o fluxo para liberar o arquivo
    sr.Close();
}
catch (Exception e)
{
    // 7. Se qualquer erro acontecer no bloco 'try', o código pula para cá
    Console.WriteLine("Ocorreu um problema na leitura do arquivo!");
    problemaArquivo = true;
}</pre>

<h4>Entendendo o Código</h4>
<ul>
    <li><code>try-catch</code>: Operações com arquivos são arriscadas (o arquivo pode não existir, estar corrompido,
        etc.). O bloco <code>try</code> tenta executar o código de leitura. Se qualquer erro (uma "exceção") ocorrer, o
        programa não trava, ele pula para o bloco <code>catch</code> e nos avisa do problema.</li>
    <li><code>StreamReader</code>: É a classe do C# responsável por ler arquivos de texto.</li>
    <li><code>sr.ReadLine()</code>: Lê uma linha inteira do arquivo e avança o "cursor" para a próxima.</li>
    <li><code>linha_arq.Split(',')</code>: Um método muito útil que quebra uma string em um vetor de strings, usando o
        caractere que você definir como separador (neste caso, a vírgula).</li>
    <li><code>int.TryParse()</code>: Uma forma segura de converter texto em número. Diferente de
        <code>int.Parse()</code>, ele não causa um erro se a conversão falhar; em vez disso, ele retorna
        <code>false</code>.
    </li>
    <li><code>sr.Close()</code>: Passo fundamental! Sempre feche o arquivo após o uso para que outros processos possam
        acessá-lo.</li>
</ul>

<p>O restante do código do jogo agora é colocado dentro de uma condição para só ser executado se o arquivo for lido com
    sucesso.</p>
<pre class="code">
if (!problemaArquivo)
{
    bool fimJogo = false;
    bool vitoria = false;
    do
    {
        // Imprime o tabuleiro do jogador a cada rodada
        for (int l = 0; l < qtdLinhas; l++)
        {
            for (int c = 0; c < qtdColunas; c++)
            {
                Console.Write(string.Format("{0} ", jogo[l, c]));
            }
            Console.Write(Environment.NewLine + Environment.NewLine);
        }

        // Pede a jogada para o usuário
        Console.Write("Selecione uma linha [1-10]: ");
        int linha = Convert.ToInt32(Console.ReadLine()) - 1;
        Console.Write("Selecione uma coluna [1-10]: ");
        int coluna = Convert.ToInt32(Console.ReadLine()) - 1;

        // Verifica o resultado da jogada
        switch (campo[linha, coluna])
        {
            case 0:
                jogo[linha, coluna] = 0;
                Console.Write("Continue tentando.\n\n");
                break;
            case 1:
                jogo[linha, coluna] = 1;
                Console.Write("BOOOM. Você perdeu.\n\n");
                fimJogo = true;
                break;
            default: // Caso encontre a bandeira (valor 2)
                jogo[linha, coluna] = 2;
                Console.Write("Parabéns. Você ganhou!\n\n");
                fimJogo = true;
                vitoria = true; // Atualiza a flag de vitória
                break;
        }
    } while (!fimJogo);
}</pre>

<hr>

<h2>3. Escrita de Dados em um Arquivo</h2>

<p>Após o fim de cada partida, vamos atualizar o placar de vitórias ou derrotas no arquivo. A estratégia será: ler todo
    o conteúdo do arquivo para a memória, modificar apenas a linha que queremos e, em seguida, reescrever o arquivo
    inteiro com o conteúdo atualizado.</p>

<h3>Código para Escrita e Explicação</h3>
<p>Este código deve ser inserido dentro do <code>if (!problemaArquivo)</code>, logo após o final do loop
    <code>do-while</code> do jogo.
</p>
<pre class="code">
try
{
    // 1. Lê todas as linhas do arquivo e guarda em um vetor de strings
    string[] arquivo = File.ReadAllLines(caminho_relativo);
    
    // Pega as linhas de vitória e derrota (penúltima e última)
    string msgVitorias = arquivo[arquivo.Length - 2];
    string msgDerrotas = arquivo[arquivo.Length - 1];

    // 2. Abre um fluxo de ESCRITA. IMPORTANTE: Isso apaga o conteúdo atual do arquivo!
    StreamWriter sw = new StreamWriter(caminho_relativo);

    int contagem;
    int linha_sobrescrever;
    string texto;

    if (vitoria)
    {
        // Pega o número depois de "Vitórias:"
        int.TryParse(msgVitorias.Split(':')[1], out contagem);
        linha_sobrescrever = 11; // A contagem de vitórias está na 12ª linha (índice 11)
        texto = "Vitórias:";
    }
    else
    {
        // Pega o número depois de "Derrotas:"
        int.TryParse(msgDerrotas.Split(':')[1], out contagem);
        linha_sobrescrever = 12; // A contagem de derrotas está na 13ª linha (índice 12)
        texto = "Derrotas:";
    }

    contagem++; // 3. Incrementa o placar

    // 4. Percorre o vetor que continha as linhas originais
    for (int i = 0; i < arquivo.Length; i++)
    {
        // Se for a linha que queremos mudar...
        if (i == linha_sobrescrever)
        {
            sw.WriteLine(texto + contagem); // Escreve a nova linha com o placar atualizado
        }
        else
        {
            sw.WriteLine(arquivo[i]); // Senão, apenas reescreve a linha original
        }
    }
    
    // 5. Fecha o fluxo para salvar as alterações no arquivo
    sw.Close();
}
catch (Exception e)
{
    Console.WriteLine("Ocorreu um problema na escrita do arquivo!");
}</pre>

<h4>Entendendo o Código</h4>
<ul>
    <li><code>File.ReadAllLines()</code>: Um atalho útil para ler um arquivo inteiro e já separá-lo em um vetor de
        strings.</li>
    <li><code>StreamWriter</code>: A classe para escrever em arquivos de texto. Criá-la com
        <code>new StreamWriter(caminho)</code> prepara o arquivo para ser completamente sobrescrito.
    </li>
    <li><code>sw.WriteLine()</code>: Escreve uma string no arquivo e automaticamente adiciona uma quebra de linha no
        final.</li>
    <li>A lógica de reescrever o arquivo inteiro é comum e segura. Ela garante que você não corrompa o arquivo ao tentar
        editar apenas uma pequena parte dele.</li>
</ul>

<p>Veja o seguinte conteúdo para melhor entendimento: <a
        href="https://learn.microsoft.com/pt-br/troubleshoot/developer/visualstudio/csharp/language-compilers/read-write-text-file"
        target="_blank" rel="external" style="color: rgb(0, 204, 255);">link</a></p>

<hr>

<h2>Considerações Finais</h2>

<p>A manipulação de arquivos é um recurso poderoso e relativamente simples para dar "memória" aos seus programas. Com as
    classes <code>StreamReader</code> e <code>StreamWriter</code>, e o uso correto de tratamento de exceções com
    <code>try-catch</code>, você pode salvar e carregar configurações, placares, progresso de jogo e muito mais,
    tornando suas aplicações mais robustas e dinâmicas.
</p>

{% include nav-aula.html materia="algoritmoseprogramacao2" aula="4" %}
{% include footer.html %}